# 实用小程序，巩固知识点

### 1.list反向排序：

**使用切片：**

```python
for i in list:
	print(i)
#按顺序输出list
```

```python
for i in list[::-1]:
    print(i)
#倒序输出list
```

**使用reveser:**

```python
>>> L = [1,2,3,4,5]
>>> L.reverse()
>>> L
[5, 4, 3, 2, 1]
```

**使用sorted:**

```python
>>> L=[1,3,4,5]
>>> sorted(L,reverse=True)
[5, 4, 3, 2, 1]           #这里sorted函数创建了一个新的列表
>>> L			          #此时L并没有改变		  
[1, 2, 3, 4, 5]
>>> L = sorted(L,reverse=True)
>>> L
[5, 4, 3, 2, 1]
```



### 2.字典排序

**按值排序：**

```python
dict1 = {'a':1,'b':10,'c':3}
dict1 = dict(sorted(dict1.items(),key=lambda x:x[1],reverse=True))
```

```python
>>> dict1 = {'a':1,'b':10,'c':3}
>>> sorted(dict1.items(),key=lambda x:x[1],reverse=True)
[('b', 10), ('c', 3), ('a', 1)]
------------------------------------------------------------------------
>>> dict1 = {'a':1,'b':10,'c':3}
>>> dict1 = dict(sorted(dict1.items(),key=lambda x:x[1],reverse=True))
>>> dict1
{'b': 10, 'c': 3, 'a': 1}
```

**按键排序：**

```python
dict1 = {'a':1,'b':10,'c':3}
dict1 = dict(sorted(dict1.items(),key=lambda x:x[0],reverse=True))
```

### 3.赋值、浅拷贝、深拷贝

浅拷贝一般体现在套嵌列表中，以以下列表list1、list2、list3、list4为例讨论：

```python
import copy
list1 = [123,'a',[1,2,3]]
list2 = list1
list3 = list1.copy()
list4 = copy.deepcopy(list1)
-------------------------------------------------------------------------------------------
list1[1] = 'A'
list1[2][1] = 7
------------------------------------------------------------------------------------------
>>> id(list1),id(list2),id(list3),id(list4)
(2205057467144, 2205057467144, 2205057466952, 2205057459976)
```

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

把`list1`、`list2`、`list3` 、`list4`当作三个人找一个楼里面的东西：

首先`list1`有一个盒子，

盒子里面放了三张纸条，

两个纸条分别记录着`123` 和`'a'` 这两个物品存放的位置，

另外一张纸条记录的是一个小盒子的位置，

惊喜宝盒里还有三个纸条分别记录着`1` ,`2` ,`3` 这三个物品的位置；

------------------------------------------------------------------------------------------------------------------------------------------

`list1` 可以很容易找到这些东西在哪里，

这时候`list2` 来了，他是`list1` 的好朋友，他也想找这些东西，

`list1` 看到好朋友来了，很高兴，

他对`list1` 说，咱俩共用这个盒子，谁想找谁找，

`list1` 和`list2` 很开心；

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

好巧不巧`list3` 也来了，他也想找那些东西，

`list1` 和他不熟，`list1` 不想和他像和`list2` 一样共用他们的箱子，

但是`list1` 是个好人不忍心拒绝，

他对`list3` 说，你拿纸笔把这三个地址抄下来，放到自己盒子里，

`list3` 很高兴，他也可以找到这些东西了；

------------------------------------------------------------------------------------------------------------------------------------------------

`list4` 也来了，听说他很有背景，

他找到`list1` 二话不说，直接做了两个盒子，让`list1` 把所有的纸条都抄给他，

大盒子放记录`123`  `'a'` 和小盒子位置的三张纸条，

小盒子放记录`1` ,`2` ,`3` 这三个物品的位置的纸条，

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

就在这时候，出现了一股神秘的力量，

这股力量把`list1` 的大盒子里的记录`a` 位置的纸条换成记录`A` 位置的纸条，

把他们小盒子里记录`2` 位置的纸条换成记录`7` 位置的纸条，

结果，到最后他们四个找到的东西有些不一样了。

---------------------------------------------------------------------------------------------------------------------------------------------------

```python
>>> list1;list2;list3;list4
[123, 'A', [1, 7, 3]]
[123, 'A', [1, 7, 3]]
[123, 'a', [1, 7, 3]]
[123, 'a', [1, 2, 3]]
```

--------------------------------------------------------------------------------------------------------------------------------------------------

1、**b = a: **赋值引用，a 和 b 都指向同一个对象。

![img](http://www.runoob.com/wp-content/uploads/2017/03/1489720931-7116-4AQC6.png)

**2、b = a.copy():** 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。

![img](http://www.runoob.com/wp-content/uploads/2017/03/1489720930-6827-Vtk4m.png)

**b = copy.deepcopy(a):** 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。

![img](http://www.runoob.com/wp-content/uploads/2017/03/1489720930-5882-BO4qO.png)

### 4.从杨辉三角和生产者消费者模式看yield

**杨辉三角：**

```python
def yanghui():
    c = 0
    # s = []
    while True:
        c = c + 1
        if c == 1:
            s = [1]
            yield s
        if c == 2:
            s = [1, 1]
            yield s
        if c > 2:
            l = []
            l.append(1)
            for i, j in enumerate(l):
                if i + 1 == len(s):
                    break
                else:
                    l.append(s[i] + s[i + 1])
            l.append(1)
            s = l
            yield l
f = yanghui()
for i in f:
    if len(i) == 10:
        break
    print(i)
--------------------------------------------------------------
输出：
[1]
[1, 1]
[1, 2, 1]
[1, 3, 3, 1]
[1, 4, 6, 4, 1]
[1, 5, 10, 10, 5, 1]
[1, 6, 15, 20, 15, 6, 1]
[1, 7, 21, 35, 35, 21, 7, 1]
[1, 8, 28, 56, 70, 56, 28, 8, 1]
```



**生产者消费者模式：** 

```python
def consumer():
    r = ''
    while True:
        #这里是这个模式的重点
        product = yield r
        if not product:
            return
        print('consumer 消费产品：',product)
        r = '好评！'
def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n += 1
        print('produce  生产产品：',n)
        r = c.send(n)
        print('consumer     反馈：',r)
    c.close()
c = consumer()
produce(c)
--------------------------------------------------------------
输出：
produce  生产产品： 1
consumer 消费产品： 1
consumer     反馈： 好评！
produce  生产产品： 2
consumer 消费产品： 2
consumer     反馈： 好评！
produce  生产产品： 3
consumer 消费产品： 3
consumer     反馈： 好评！
produce  生产产品： 4
consumer 消费产品： 4
consumer     反馈： 好评！
produce  生产产品： 5
consumer 消费产品： 5
consumer     反馈： 好评！
```

